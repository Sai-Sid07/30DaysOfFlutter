pubspec.yaml - File where all packages are added
android folder - anything and everything related to android development
ios folder - anything and everything related to ios development
things related to flutter is done inside the lib folder

stl -> Creates a Flutter Stateless Widget
The build method is what is called everytime we refresh the UI

Dart:
* Dart needs semicolons

* String Interpolation in Dart:
child: Text("${name}${days}${name2}${float}") and child: Text("$name$days$name2$float")
Both are examples of String Interpolation and the difference between {} and not using {} is that
we can include complex expressions inside {} like accessing an array and calling a method and so on.
Ex: child: Text("$name$days${"${name2}Hi"}$float") or child: Text("$name$days${name2 + "Hi"}$float")

* DataTypes:
    int days = 30;
    double float = 2.0;
    String name = "Welcome to ";
    String name2 = " days of Flutter ";
    bool isMale = true;
    num number = 1; //Can take the form of int or double
    var variable = "Hello"; //Compiler Decides the datatype based on value
    const pi = 3.14; //Cannot change the value
    final f = "Hello";
    The difference between const and final is that:
    The value of const must be decided during compile time but final need not be.
    Ex: When making an API call, we don't know the value during compile time and hence final can be used in this case.
    Another example is we can use const when assigning values like 1 + 2 but cannot be used when setting the current time 
    because that is variable in nature.
    
    Definition from Docs:
    "final" means single-assignment: a final variable or field must have an initializer. 
    Once assigned a value, a final variable's value cannot be changed. final modifies variables.
    const means that the object's entire deep state can be determined entirely at compile time and that the object 
    will be frozen and completely immutable.

* Scafold Widget:
appBar -> Equivalent to header
body -> Main content
Everything in flutter is a widget
For Footer - 
bottomNavigationBar, drawer etc
In Flutter, most of the times, the name of the widget is the name of the property

One good practice is that hover over each attribute to see the type of value it wants and then pass it accordingly.

* Functions:
returnType functionName(){

}
In case we want to have optional parameters where if the parameter isn't specified, we fix a default value
returnType functionName({int param = value}){}
when calling the function: functionNmae(param: value or leave it blank);

If we want to fix a required parameter then we use the decorator @required
returnType functionName({@required bool param1, int param2 = value}){}
Method -> Inside a class
Function -> Outside a class, standalone
Passing an argument when calling a function - (parameter:value)

void main() {
  //Main Entry Point
  //runApp is the method to call your class with the main app code
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(home: HomePage());
  }
}
BuildContext context gives us the context related information about which function resides in which file
Gives context about the location of the function in the Tree(Structure of the file).
Inside materialApp, we have multiple options like Themes:
themeMode: ThemeMode.dark, //Uses the design choice mentioned inside darkTheme
      darkTheme: ThemeData(
        brightness: Brightness.dark
      ), -> To implement dark mode and its settings

Sample:
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: HomePage(),
      themeMode: ThemeMode.dark, //Uses the design choice mentioned inside darkTheme
      theme: ThemeData(
        primarySwatch: Colors.amber //Primary Swatch matches all the UI elements with the specified scheme
      ),
      darkTheme: ThemeData(
        brightness: Brightness.dark,
        appBarTheme: AppBarTheme( //This is overriden if a theme is applied in nested functions
          color: Color.fromARGB(255, 255, 238, 0) //App bar
        ),
        canvasColor: Color.fromARGB(255, 0, 0, 0) //Background
      ),
    );
  }

* Routes in Flutter:
/ is the home route and in your App body, either have home: or "/" : (context) => HomePage(). Having both will cause an error
initialRoute - This specifies the base route that should be considered. If you want it different from "/"

Classes - Name and subword always start with capital letters.
Functions - Follows camelCase

* Flow of Flutter
In Flutter, every Widget is a parent and it can carry atmost one child. (Nest another widget inside it)

In order to add images to your Flutter application, go to pubspec.yaml, 
add a key named assets:
then create a folder in your root directory and provide the path as a value inside the assets key.
Now we can access all the files needed in our project.
Format:-
assets:
    - path1
    - path2
Tip: Include the full path of the image folder so you can access all the images in one go rather than doing it individually.

In Flutter, Column -> Main Axis is Vertical Axis, Row -> Main Axis is Horizontal Axis
Note: Image.asset() doesn't belong to a const type, having the parent widget as const throws an error hence avoid this mistake.

In order to use External Libraries in your Flutter application, use pub.dev to get installation instructions for all packages
If you want spacing between Widgets, then use SizedBox instead of Padding. SizedBox gives you an empty box with Height and Width specified
Ways to get input from the user:
    * TextFormField() - This is what is recommended to be used
    * TextField()

Another thing to note in Flutter is that, the Child Argument should always be the last argument in a constructor. 
(Throws a warning not an error)

* Navigation in Flutter - Using Routes
We use the class Navigator to navigate between pages
You can consider Navigator to act like a stack and you can move between pages.
Navigator.push -> To move a class/page forward
Navigator.pop -> To move one class/page behind

debugShowCheckedModeBanner: false, -> Add this property in the main file to remove the debug marker

* Difference between Stateless and Stateful Widget
State - Anything that can change
If we have any page where the contents of the page are changed or re-rendered, then it becomes a stateful widget
Each component can save its own state in order to improve performance and remove unneccessary re-rendering of pages.

A Stateful Widget will have 2 classes while a Stateless widget will have a single class.
_classname - Private Class naming scheme in dart

Once we have made changes to the code and in order to see the state changing on the screen, 
we have to reload the entire state. We invoke the method setState() in-order to reload the page.
This functions calls the build method which will reload the widget of the window.

When using BoxDecoration - Give the background color inside. Because we cannot have 2 colors defined and it will throw an error.
Define only one background color inside that widget and that should be inside BoxDecoration

In order to have a click functionality for a container, you have to wrap it with Jester or Inkwell. 
The difference is that Inkwell will provide a ripple effect (or feedback) on clicking the container but jester doesn't.

A point to note:
Lets say our widget is structured like this - 
Material 
  | InkWell
    | AnimatedContainer
      -> Contains a decoration

Now if material tries creating a decoration like background color or border, those changes will not be reflected.
Hence, we should always have our decorations placed inside the ancestors and not the children. 

=> Shorthand operator and its used when you have one line functions

Bang Operator (!) -
In traditional languages, when using conditions, we add a ? to the variable to tell the compiler that 
there may or may not be a null value.
But in Dart, this could result in a compiler time error, so we use the ! operator to tell the compiler that
there won't be a null value in any case.

* Forms - 
In order to have form validation. we add a Widget called Form and nest the child widgets inside that.
Each input/TextFormField will have an argument called validator where we can define the validation metrics.
The first thing we need to do is to have a unique Key for that form which can be globally accessed.
final _formKey (private variable) = GlobalKey<FormState>();
This needs to be passed as key: _formKey inside the Form widget.
We then invoke the validate() method which runs the validator conditions for those inputs.


When using Images from your local device, you use Image.asset.
When using Images through URLs, we use Image.network(imageURL)

* Drawer - 
Uses the Drawer() to implement a drawer in Flutter.
Since we want elements stack one below each other, we use ListView() to render elements.
To set a Drawer Header with Username, email, Display Picture, we use DrawerHeader() to achieve this effect.
DrawerHeader(
  child: UserAccountsDrawerHeader(
    has 2 required fields:
    accountName:
    accountEmail:
    currentAccountPicture:
  )
)
For currentAccountPicture, we can directly pass Image.asset/network to render the image.
But incase we want a circular image, then we will - 
CircularAvatar(
  //This creates a Circular Placeholder.
  If we use child property, then the image will overlap the circle.
  We will rather use backgroundImage to achieve this.
  backgroundImage takes in parameter of type ImageProvider, hence we use NetworkImage or AssetImage property.
)

Inside ListView, we have ListTile which will help us create tabs and it has a 2 properties:
leading: -> The icon for that tab and title: Name of that tab
It also has a onTap function which will help us route between pages